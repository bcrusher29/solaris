package xbmc

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// MarshalMsg implements msgp.Marshaler
func (z ActivePlayers) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendArrayHeader(o, uint32(len(z)))
	for za0001 := range z {
		// map header, size 2
		// string "ID"
		o = append(o, 0x82, 0xa2, 0x49, 0x44)
		o = msgp.AppendInt(o, z[za0001].ID)
		// string "Type"
		o = append(o, 0xa4, 0x54, 0x79, 0x70, 0x65)
		o = msgp.AppendString(o, z[za0001].Type)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ActivePlayers) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0002 uint32
	zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if cap((*z)) >= int(zb0002) {
		(*z) = (*z)[:zb0002]
	} else {
		(*z) = make(ActivePlayers, zb0002)
	}
	for zb0001 := range *z {
		var field []byte
		_ = field
		var zb0003 uint32
		zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
		if err != nil {
			return
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				return
			}
			switch msgp.UnsafeString(field) {
			case "ID":
				(*z)[zb0001].ID, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					return
				}
			case "Type":
				(*z)[zb0001].Type, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					return
				}
			default:
				bts, err = msgp.Skip(bts)
				if err != nil {
					return
				}
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ActivePlayers) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize
	for zb0004 := range z {
		s += 1 + 3 + msgp.IntSize + 5 + msgp.StringPrefixSize + len(z[zb0004].Type)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *AdvancedSettings) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "LogLevel"
	o = append(o, 0x82, 0xa8, 0x4c, 0x6f, 0x67, 0x4c, 0x65, 0x76, 0x65, 0x6c)
	o = msgp.AppendInt(o, z.LogLevel)
	// string "Cache"
	// map header, size 4
	// string "MemorySizeLegacy"
	o = append(o, 0xa5, 0x43, 0x61, 0x63, 0x68, 0x65, 0x84, 0xb0, 0x4d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x53, 0x69, 0x7a, 0x65, 0x4c, 0x65, 0x67, 0x61, 0x63, 0x79)
	o = msgp.AppendInt(o, z.Cache.MemorySizeLegacy)
	// string "MemorySize"
	o = append(o, 0xaa, 0x4d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x53, 0x69, 0x7a, 0x65)
	o = msgp.AppendInt(o, z.Cache.MemorySize)
	// string "BufferMode"
	o = append(o, 0xaa, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x4d, 0x6f, 0x64, 0x65)
	o = msgp.AppendInt(o, z.Cache.BufferMode)
	// string "ReadFactor"
	o = append(o, 0xaa, 0x52, 0x65, 0x61, 0x64, 0x46, 0x61, 0x63, 0x74, 0x6f, 0x72)
	o = msgp.AppendInt(o, z.Cache.ReadFactor)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AdvancedSettings) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			return
		}
		switch msgp.UnsafeString(field) {
		case "LogLevel":
			z.LogLevel, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "Cache":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					return
				}
				switch msgp.UnsafeString(field) {
				case "MemorySizeLegacy":
					z.Cache.MemorySizeLegacy, bts, err = msgp.ReadIntBytes(bts)
					if err != nil {
						return
					}
				case "MemorySize":
					z.Cache.MemorySize, bts, err = msgp.ReadIntBytes(bts)
					if err != nil {
						return
					}
				case "BufferMode":
					z.Cache.BufferMode, bts, err = msgp.ReadIntBytes(bts)
					if err != nil {
						return
					}
				case "ReadFactor":
					z.Cache.ReadFactor, bts, err = msgp.ReadIntBytes(bts)
					if err != nil {
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *AdvancedSettings) Msgsize() (s int) {
	s = 1 + 9 + msgp.IntSize + 6 + 1 + 17 + msgp.IntSize + 11 + msgp.IntSize + 11 + msgp.IntSize + 11 + msgp.IntSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ContextMenuItem) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "Label"
	o = append(o, 0x82, 0xa5, 0x4c, 0x61, 0x62, 0x65, 0x6c)
	o = msgp.AppendString(o, z.Label)
	// string "Action"
	o = append(o, 0xa6, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Action)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ContextMenuItem) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			return
		}
		switch msgp.UnsafeString(field) {
		case "Label":
			z.Label, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Action":
			z.Action, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ContextMenuItem) Msgsize() (s int) {
	s = 1 + 6 + msgp.StringPrefixSize + len(z.Label) + 7 + msgp.StringPrefixSize + len(z.Action)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *FileSources) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "Sources"
	o = append(o, 0x81, 0xa7, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Sources)))
	for za0001 := range z.Sources {
		// map header, size 2
		// string "FilePath"
		o = append(o, 0x82, 0xa8, 0x46, 0x69, 0x6c, 0x65, 0x50, 0x61, 0x74, 0x68)
		o = msgp.AppendString(o, z.Sources[za0001].FilePath)
		// string "Label"
		o = append(o, 0xa5, 0x4c, 0x61, 0x62, 0x65, 0x6c)
		o = msgp.AppendString(o, z.Sources[za0001].Label)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *FileSources) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			return
		}
		switch msgp.UnsafeString(field) {
		case "Sources":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				return
			}
			if cap(z.Sources) >= int(zb0002) {
				z.Sources = (z.Sources)[:zb0002]
			} else {
				z.Sources = make([]struct {
					FilePath string `json:"file"`
					Label    string `json:"label"`
				}, zb0002)
			}
			for za0001 := range z.Sources {
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						return
					}
					switch msgp.UnsafeString(field) {
					case "FilePath":
						z.Sources[za0001].FilePath, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							return
						}
					case "Label":
						z.Sources[za0001].Label, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							return
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *FileSources) Msgsize() (s int) {
	s = 1 + 8 + msgp.ArrayHeaderSize
	for za0001 := range z.Sources {
		s += 1 + 9 + msgp.StringPrefixSize + len(z.Sources[za0001].FilePath) + 6 + msgp.StringPrefixSize + len(z.Sources[za0001].Label)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z GUIIconOverlay) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *GUIIconOverlay) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 int
		zb0001, bts, err = msgp.ReadIntBytes(bts)
		if err != nil {
			return
		}
		(*z) = GUIIconOverlay(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z GUIIconOverlay) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ListItem) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 12
	// string "Label"
	o = append(o, 0x8c, 0xa5, 0x4c, 0x61, 0x62, 0x65, 0x6c)
	o = msgp.AppendString(o, z.Label)
	// string "Label2"
	o = append(o, 0xa6, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x32)
	o = msgp.AppendString(o, z.Label2)
	// string "Icon"
	o = append(o, 0xa4, 0x49, 0x63, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Icon)
	// string "Thumbnail"
	o = append(o, 0xa9, 0x54, 0x68, 0x75, 0x6d, 0x62, 0x6e, 0x61, 0x69, 0x6c)
	o = msgp.AppendString(o, z.Thumbnail)
	// string "IsPlayable"
	o = append(o, 0xaa, 0x49, 0x73, 0x50, 0x6c, 0x61, 0x79, 0x61, 0x62, 0x6c, 0x65)
	o = msgp.AppendBool(o, z.IsPlayable)
	// string "Path"
	o = append(o, 0xa4, 0x50, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.Path)
	// string "Info"
	o = append(o, 0xa4, 0x49, 0x6e, 0x66, 0x6f)
	if z.Info == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Info.MarshalMsg(o)
		if err != nil {
			return
		}
	}
	// string "Properties"
	o = append(o, 0xaa, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73)
	o = msgp.AppendMapHeader(o, uint32(len(z.Properties)))
	for za0001, za0002 := range z.Properties {
		o = msgp.AppendString(o, za0001)
		o = msgp.AppendString(o, za0002)
	}
	// string "Art"
	o = append(o, 0xa3, 0x41, 0x72, 0x74)
	if z.Art == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Art.MarshalMsg(o)
		if err != nil {
			return
		}
	}
	// string "StreamInfo"
	o = append(o, 0xaa, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x49, 0x6e, 0x66, 0x6f)
	if z.StreamInfo == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.StreamInfo.MarshalMsg(o)
		if err != nil {
			return
		}
	}
	// string "ContextMenu"
	o = append(o, 0xab, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x4d, 0x65, 0x6e, 0x75)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ContextMenu)))
	for za0003 := range z.ContextMenu {
		o = msgp.AppendArrayHeader(o, uint32(len(z.ContextMenu[za0003])))
		for za0004 := range z.ContextMenu[za0003] {
			o = msgp.AppendString(o, z.ContextMenu[za0003][za0004])
		}
	}
	// string "TraktAuth"
	o = append(o, 0xa9, 0x54, 0x72, 0x61, 0x6b, 0x74, 0x41, 0x75, 0x74, 0x68)
	o = msgp.AppendBool(o, z.TraktAuth)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ListItem) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			return
		}
		switch msgp.UnsafeString(field) {
		case "Label":
			z.Label, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Label2":
			z.Label2, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Icon":
			z.Icon, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Thumbnail":
			z.Thumbnail, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "IsPlayable":
			z.IsPlayable, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				return
			}
		case "Path":
			z.Path, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Info":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Info = nil
			} else {
				if z.Info == nil {
					z.Info = new(ListItemInfo)
				}
				bts, err = z.Info.UnmarshalMsg(bts)
				if err != nil {
					return
				}
			}
		case "Properties":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				return
			}
			if z.Properties == nil && zb0002 > 0 {
				z.Properties = make(map[string]string, zb0002)
			} else if len(z.Properties) > 0 {
				for key := range z.Properties {
					delete(z.Properties, key)
				}
			}
			for zb0002 > 0 {
				var za0001 string
				var za0002 string
				zb0002--
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					return
				}
				za0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					return
				}
				z.Properties[za0001] = za0002
			}
		case "Art":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Art = nil
			} else {
				if z.Art == nil {
					z.Art = new(ListItemArt)
				}
				bts, err = z.Art.UnmarshalMsg(bts)
				if err != nil {
					return
				}
			}
		case "StreamInfo":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.StreamInfo = nil
			} else {
				if z.StreamInfo == nil {
					z.StreamInfo = new(StreamInfo)
				}
				bts, err = z.StreamInfo.UnmarshalMsg(bts)
				if err != nil {
					return
				}
			}
		case "ContextMenu":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				return
			}
			if cap(z.ContextMenu) >= int(zb0003) {
				z.ContextMenu = (z.ContextMenu)[:zb0003]
			} else {
				z.ContextMenu = make([][]string, zb0003)
			}
			for za0003 := range z.ContextMenu {
				var zb0004 uint32
				zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					return
				}
				if cap(z.ContextMenu[za0003]) >= int(zb0004) {
					z.ContextMenu[za0003] = (z.ContextMenu[za0003])[:zb0004]
				} else {
					z.ContextMenu[za0003] = make([]string, zb0004)
				}
				for za0004 := range z.ContextMenu[za0003] {
					z.ContextMenu[za0003][za0004], bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						return
					}
				}
			}
		case "TraktAuth":
			z.TraktAuth, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ListItem) Msgsize() (s int) {
	s = 1 + 6 + msgp.StringPrefixSize + len(z.Label) + 7 + msgp.StringPrefixSize + len(z.Label2) + 5 + msgp.StringPrefixSize + len(z.Icon) + 10 + msgp.StringPrefixSize + len(z.Thumbnail) + 11 + msgp.BoolSize + 5 + msgp.StringPrefixSize + len(z.Path) + 5
	if z.Info == nil {
		s += msgp.NilSize
	} else {
		s += z.Info.Msgsize()
	}
	s += 11 + msgp.MapHeaderSize
	if z.Properties != nil {
		for za0001, za0002 := range z.Properties {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + msgp.StringPrefixSize + len(za0002)
		}
	}
	s += 4
	if z.Art == nil {
		s += msgp.NilSize
	} else {
		s += z.Art.Msgsize()
	}
	s += 11
	if z.StreamInfo == nil {
		s += msgp.NilSize
	} else {
		s += z.StreamInfo.Msgsize()
	}
	s += 12 + msgp.ArrayHeaderSize
	for za0003 := range z.ContextMenu {
		s += msgp.ArrayHeaderSize
		for za0004 := range z.ContextMenu[za0003] {
			s += msgp.StringPrefixSize + len(z.ContextMenu[za0003][za0004])
		}
	}
	s += 10 + msgp.BoolSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ListItemArt) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 9
	// string "Thumbnail"
	o = append(o, 0x89, 0xa9, 0x54, 0x68, 0x75, 0x6d, 0x62, 0x6e, 0x61, 0x69, 0x6c)
	o = msgp.AppendString(o, z.Thumbnail)
	// string "Poster"
	o = append(o, 0xa6, 0x50, 0x6f, 0x73, 0x74, 0x65, 0x72)
	o = msgp.AppendString(o, z.Poster)
	// string "TvShowPoster"
	o = append(o, 0xac, 0x54, 0x76, 0x53, 0x68, 0x6f, 0x77, 0x50, 0x6f, 0x73, 0x74, 0x65, 0x72)
	o = msgp.AppendString(o, z.TvShowPoster)
	// string "Banner"
	o = append(o, 0xa6, 0x42, 0x61, 0x6e, 0x6e, 0x65, 0x72)
	o = msgp.AppendString(o, z.Banner)
	// string "FanArt"
	o = append(o, 0xa6, 0x46, 0x61, 0x6e, 0x41, 0x72, 0x74)
	o = msgp.AppendString(o, z.FanArt)
	// string "ClearArt"
	o = append(o, 0xa8, 0x43, 0x6c, 0x65, 0x61, 0x72, 0x41, 0x72, 0x74)
	o = msgp.AppendString(o, z.ClearArt)
	// string "ClearLogo"
	o = append(o, 0xa9, 0x43, 0x6c, 0x65, 0x61, 0x72, 0x4c, 0x6f, 0x67, 0x6f)
	o = msgp.AppendString(o, z.ClearLogo)
	// string "Landscape"
	o = append(o, 0xa9, 0x4c, 0x61, 0x6e, 0x64, 0x73, 0x63, 0x61, 0x70, 0x65)
	o = msgp.AppendString(o, z.Landscape)
	// string "Icon"
	o = append(o, 0xa4, 0x49, 0x63, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Icon)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ListItemArt) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			return
		}
		switch msgp.UnsafeString(field) {
		case "Thumbnail":
			z.Thumbnail, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Poster":
			z.Poster, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "TvShowPoster":
			z.TvShowPoster, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Banner":
			z.Banner, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "FanArt":
			z.FanArt, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "ClearArt":
			z.ClearArt, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "ClearLogo":
			z.ClearLogo, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Landscape":
			z.Landscape, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Icon":
			z.Icon, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ListItemArt) Msgsize() (s int) {
	s = 1 + 10 + msgp.StringPrefixSize + len(z.Thumbnail) + 7 + msgp.StringPrefixSize + len(z.Poster) + 13 + msgp.StringPrefixSize + len(z.TvShowPoster) + 7 + msgp.StringPrefixSize + len(z.Banner) + 7 + msgp.StringPrefixSize + len(z.FanArt) + 9 + msgp.StringPrefixSize + len(z.ClearArt) + 10 + msgp.StringPrefixSize + len(z.ClearLogo) + 10 + msgp.StringPrefixSize + len(z.Landscape) + 5 + msgp.StringPrefixSize + len(z.Icon)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ListItemInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 44
	// string "Count"
	o = append(o, 0xde, 0x0, 0x2c, 0xa5, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendInt(o, z.Count)
	// string "Size"
	o = append(o, 0xa4, 0x53, 0x69, 0x7a, 0x65)
	o = msgp.AppendInt(o, z.Size)
	// string "Date"
	o = append(o, 0xa4, 0x44, 0x61, 0x74, 0x65)
	o = msgp.AppendString(o, z.Date)
	// string "Genre"
	o = append(o, 0xa5, 0x47, 0x65, 0x6e, 0x72, 0x65)
	o = msgp.AppendString(o, z.Genre)
	// string "Year"
	o = append(o, 0xa4, 0x59, 0x65, 0x61, 0x72)
	o = msgp.AppendInt(o, z.Year)
	// string "Episode"
	o = append(o, 0xa7, 0x45, 0x70, 0x69, 0x73, 0x6f, 0x64, 0x65)
	o = msgp.AppendInt(o, z.Episode)
	// string "Season"
	o = append(o, 0xa6, 0x53, 0x65, 0x61, 0x73, 0x6f, 0x6e)
	o = msgp.AppendInt(o, z.Season)
	// string "Top250"
	o = append(o, 0xa6, 0x54, 0x6f, 0x70, 0x32, 0x35, 0x30)
	o = msgp.AppendInt(o, z.Top250)
	// string "TrackNumber"
	o = append(o, 0xab, 0x54, 0x72, 0x61, 0x63, 0x6b, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72)
	o = msgp.AppendInt(o, z.TrackNumber)
	// string "Rating"
	o = append(o, 0xa6, 0x52, 0x61, 0x74, 0x69, 0x6e, 0x67)
	o = msgp.AppendFloat32(o, z.Rating)
	// string "PlayCount"
	o = append(o, 0xa9, 0x50, 0x6c, 0x61, 0x79, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendInt(o, z.PlayCount)
	// string "Overlay"
	o = append(o, 0xa7, 0x4f, 0x76, 0x65, 0x72, 0x6c, 0x61, 0x79)
	o = msgp.AppendInt(o, int(z.Overlay))
	// string "Cast"
	o = append(o, 0xa4, 0x43, 0x61, 0x73, 0x74)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Cast)))
	for za0001 := range z.Cast {
		o = msgp.AppendString(o, z.Cast[za0001])
	}
	// string "CastAndRole"
	o = append(o, 0xab, 0x43, 0x61, 0x73, 0x74, 0x41, 0x6e, 0x64, 0x52, 0x6f, 0x6c, 0x65)
	o = msgp.AppendArrayHeader(o, uint32(len(z.CastAndRole)))
	for za0002 := range z.CastAndRole {
		o = msgp.AppendArrayHeader(o, uint32(len(z.CastAndRole[za0002])))
		for za0003 := range z.CastAndRole[za0002] {
			o = msgp.AppendString(o, z.CastAndRole[za0002][za0003])
		}
	}
	// string "Director"
	o = append(o, 0xa8, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6f, 0x72)
	o = msgp.AppendString(o, z.Director)
	// string "MPAA"
	o = append(o, 0xa4, 0x4d, 0x50, 0x41, 0x41)
	o = msgp.AppendString(o, z.MPAA)
	// string "Plot"
	o = append(o, 0xa4, 0x50, 0x6c, 0x6f, 0x74)
	o = msgp.AppendString(o, z.Plot)
	// string "PlotOutline"
	o = append(o, 0xab, 0x50, 0x6c, 0x6f, 0x74, 0x4f, 0x75, 0x74, 0x6c, 0x69, 0x6e, 0x65)
	o = msgp.AppendString(o, z.PlotOutline)
	// string "Title"
	o = append(o, 0xa5, 0x54, 0x69, 0x74, 0x6c, 0x65)
	o = msgp.AppendString(o, z.Title)
	// string "OriginalTitle"
	o = append(o, 0xad, 0x4f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x61, 0x6c, 0x54, 0x69, 0x74, 0x6c, 0x65)
	o = msgp.AppendString(o, z.OriginalTitle)
	// string "SortTitle"
	o = append(o, 0xa9, 0x53, 0x6f, 0x72, 0x74, 0x54, 0x69, 0x74, 0x6c, 0x65)
	o = msgp.AppendString(o, z.SortTitle)
	// string "Duration"
	o = append(o, 0xa8, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendInt(o, z.Duration)
	// string "Studio"
	o = append(o, 0xa6, 0x53, 0x74, 0x75, 0x64, 0x69, 0x6f)
	o = msgp.AppendString(o, z.Studio)
	// string "TagLine"
	o = append(o, 0xa7, 0x54, 0x61, 0x67, 0x4c, 0x69, 0x6e, 0x65)
	o = msgp.AppendString(o, z.TagLine)
	// string "Writer"
	o = append(o, 0xa6, 0x57, 0x72, 0x69, 0x74, 0x65, 0x72)
	o = msgp.AppendString(o, z.Writer)
	// string "TVShowTitle"
	o = append(o, 0xab, 0x54, 0x56, 0x53, 0x68, 0x6f, 0x77, 0x54, 0x69, 0x74, 0x6c, 0x65)
	o = msgp.AppendString(o, z.TVShowTitle)
	// string "Premiered"
	o = append(o, 0xa9, 0x50, 0x72, 0x65, 0x6d, 0x69, 0x65, 0x72, 0x65, 0x64)
	o = msgp.AppendString(o, z.Premiered)
	// string "Status"
	o = append(o, 0xa6, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73)
	o = msgp.AppendString(o, z.Status)
	// string "Code"
	o = append(o, 0xa4, 0x43, 0x6f, 0x64, 0x65)
	o = msgp.AppendString(o, z.Code)
	// string "Aired"
	o = append(o, 0xa5, 0x41, 0x69, 0x72, 0x65, 0x64)
	o = msgp.AppendString(o, z.Aired)
	// string "Credits"
	o = append(o, 0xa7, 0x43, 0x72, 0x65, 0x64, 0x69, 0x74, 0x73)
	o = msgp.AppendString(o, z.Credits)
	// string "LastPlayed"
	o = append(o, 0xaa, 0x4c, 0x61, 0x73, 0x74, 0x50, 0x6c, 0x61, 0x79, 0x65, 0x64)
	o = msgp.AppendString(o, z.LastPlayed)
	// string "Album"
	o = append(o, 0xa5, 0x41, 0x6c, 0x62, 0x75, 0x6d)
	o = msgp.AppendString(o, z.Album)
	// string "Artist"
	o = append(o, 0xa6, 0x41, 0x72, 0x74, 0x69, 0x73, 0x74)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Artist)))
	for za0004 := range z.Artist {
		o = msgp.AppendString(o, z.Artist[za0004])
	}
	// string "Votes"
	o = append(o, 0xa5, 0x56, 0x6f, 0x74, 0x65, 0x73)
	o = msgp.AppendString(o, z.Votes)
	// string "Trailer"
	o = append(o, 0xa7, 0x54, 0x72, 0x61, 0x69, 0x6c, 0x65, 0x72)
	o = msgp.AppendString(o, z.Trailer)
	// string "DateAdded"
	o = append(o, 0xa9, 0x44, 0x61, 0x74, 0x65, 0x41, 0x64, 0x64, 0x65, 0x64)
	o = msgp.AppendString(o, z.DateAdded)
	// string "DBID"
	o = append(o, 0xa4, 0x44, 0x42, 0x49, 0x44)
	o = msgp.AppendInt(o, z.DBID)
	// string "DBTYPE"
	o = append(o, 0xa6, 0x44, 0x42, 0x54, 0x59, 0x50, 0x45)
	o = msgp.AppendString(o, z.DBTYPE)
	// string "Mediatype"
	o = append(o, 0xa9, 0x4d, 0x65, 0x64, 0x69, 0x61, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Mediatype)
	// string "IMDBNumber"
	o = append(o, 0xaa, 0x49, 0x4d, 0x44, 0x42, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72)
	o = msgp.AppendString(o, z.IMDBNumber)
	// string "Lyrics"
	o = append(o, 0xa6, 0x4c, 0x79, 0x72, 0x69, 0x63, 0x73)
	o = msgp.AppendString(o, z.Lyrics)
	// string "PicturePath"
	o = append(o, 0xab, 0x50, 0x69, 0x63, 0x74, 0x75, 0x72, 0x65, 0x50, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.PicturePath)
	// string "Exif"
	o = append(o, 0xa4, 0x45, 0x78, 0x69, 0x66)
	o = msgp.AppendString(o, z.Exif)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ListItemInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			return
		}
		switch msgp.UnsafeString(field) {
		case "Count":
			z.Count, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "Size":
			z.Size, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "Date":
			z.Date, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Genre":
			z.Genre, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Year":
			z.Year, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "Episode":
			z.Episode, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "Season":
			z.Season, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "Top250":
			z.Top250, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "TrackNumber":
			z.TrackNumber, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "Rating":
			z.Rating, bts, err = msgp.ReadFloat32Bytes(bts)
			if err != nil {
				return
			}
		case "PlayCount":
			z.PlayCount, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "Overlay":
			{
				var zb0002 int
				zb0002, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					return
				}
				z.Overlay = GUIIconOverlay(zb0002)
			}
		case "Cast":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				return
			}
			if cap(z.Cast) >= int(zb0003) {
				z.Cast = (z.Cast)[:zb0003]
			} else {
				z.Cast = make([]string, zb0003)
			}
			for za0001 := range z.Cast {
				z.Cast[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					return
				}
			}
		case "CastAndRole":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				return
			}
			if cap(z.CastAndRole) >= int(zb0004) {
				z.CastAndRole = (z.CastAndRole)[:zb0004]
			} else {
				z.CastAndRole = make([][]string, zb0004)
			}
			for za0002 := range z.CastAndRole {
				var zb0005 uint32
				zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					return
				}
				if cap(z.CastAndRole[za0002]) >= int(zb0005) {
					z.CastAndRole[za0002] = (z.CastAndRole[za0002])[:zb0005]
				} else {
					z.CastAndRole[za0002] = make([]string, zb0005)
				}
				for za0003 := range z.CastAndRole[za0002] {
					z.CastAndRole[za0002][za0003], bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						return
					}
				}
			}
		case "Director":
			z.Director, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "MPAA":
			z.MPAA, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Plot":
			z.Plot, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "PlotOutline":
			z.PlotOutline, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Title":
			z.Title, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "OriginalTitle":
			z.OriginalTitle, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "SortTitle":
			z.SortTitle, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Duration":
			z.Duration, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "Studio":
			z.Studio, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "TagLine":
			z.TagLine, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Writer":
			z.Writer, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "TVShowTitle":
			z.TVShowTitle, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Premiered":
			z.Premiered, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Status":
			z.Status, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Code":
			z.Code, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Aired":
			z.Aired, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Credits":
			z.Credits, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "LastPlayed":
			z.LastPlayed, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Album":
			z.Album, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Artist":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				return
			}
			if cap(z.Artist) >= int(zb0006) {
				z.Artist = (z.Artist)[:zb0006]
			} else {
				z.Artist = make([]string, zb0006)
			}
			for za0004 := range z.Artist {
				z.Artist[za0004], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					return
				}
			}
		case "Votes":
			z.Votes, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Trailer":
			z.Trailer, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "DateAdded":
			z.DateAdded, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "DBID":
			z.DBID, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "DBTYPE":
			z.DBTYPE, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Mediatype":
			z.Mediatype, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "IMDBNumber":
			z.IMDBNumber, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Lyrics":
			z.Lyrics, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "PicturePath":
			z.PicturePath, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Exif":
			z.Exif, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ListItemInfo) Msgsize() (s int) {
	s = 3 + 6 + msgp.IntSize + 5 + msgp.IntSize + 5 + msgp.StringPrefixSize + len(z.Date) + 6 + msgp.StringPrefixSize + len(z.Genre) + 5 + msgp.IntSize + 8 + msgp.IntSize + 7 + msgp.IntSize + 7 + msgp.IntSize + 12 + msgp.IntSize + 7 + msgp.Float32Size + 10 + msgp.IntSize + 8 + msgp.IntSize + 5 + msgp.ArrayHeaderSize
	for za0001 := range z.Cast {
		s += msgp.StringPrefixSize + len(z.Cast[za0001])
	}
	s += 12 + msgp.ArrayHeaderSize
	for za0002 := range z.CastAndRole {
		s += msgp.ArrayHeaderSize
		for za0003 := range z.CastAndRole[za0002] {
			s += msgp.StringPrefixSize + len(z.CastAndRole[za0002][za0003])
		}
	}
	s += 9 + msgp.StringPrefixSize + len(z.Director) + 5 + msgp.StringPrefixSize + len(z.MPAA) + 5 + msgp.StringPrefixSize + len(z.Plot) + 12 + msgp.StringPrefixSize + len(z.PlotOutline) + 6 + msgp.StringPrefixSize + len(z.Title) + 14 + msgp.StringPrefixSize + len(z.OriginalTitle) + 10 + msgp.StringPrefixSize + len(z.SortTitle) + 9 + msgp.IntSize + 7 + msgp.StringPrefixSize + len(z.Studio) + 8 + msgp.StringPrefixSize + len(z.TagLine) + 7 + msgp.StringPrefixSize + len(z.Writer) + 12 + msgp.StringPrefixSize + len(z.TVShowTitle) + 10 + msgp.StringPrefixSize + len(z.Premiered) + 7 + msgp.StringPrefixSize + len(z.Status) + 5 + msgp.StringPrefixSize + len(z.Code) + 6 + msgp.StringPrefixSize + len(z.Aired) + 8 + msgp.StringPrefixSize + len(z.Credits) + 11 + msgp.StringPrefixSize + len(z.LastPlayed) + 6 + msgp.StringPrefixSize + len(z.Album) + 7 + msgp.ArrayHeaderSize
	for za0004 := range z.Artist {
		s += msgp.StringPrefixSize + len(z.Artist[za0004])
	}
	s += 6 + msgp.StringPrefixSize + len(z.Votes) + 8 + msgp.StringPrefixSize + len(z.Trailer) + 10 + msgp.StringPrefixSize + len(z.DateAdded) + 5 + msgp.IntSize + 7 + msgp.StringPrefixSize + len(z.DBTYPE) + 10 + msgp.StringPrefixSize + len(z.Mediatype) + 11 + msgp.StringPrefixSize + len(z.IMDBNumber) + 7 + msgp.StringPrefixSize + len(z.Lyrics) + 12 + msgp.StringPrefixSize + len(z.PicturePath) + 5 + msgp.StringPrefixSize + len(z.Exif)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ListItems) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendArrayHeader(o, uint32(len(z)))
	for za0001 := range z {
		if z[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z[za0001].MarshalMsg(o)
			if err != nil {
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ListItems) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0002 uint32
	zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if cap((*z)) >= int(zb0002) {
		(*z) = (*z)[:zb0002]
	} else {
		(*z) = make(ListItems, zb0002)
	}
	for zb0001 := range *z {
		if msgp.IsNil(bts) {
			bts, err = msgp.ReadNilBytes(bts)
			if err != nil {
				return
			}
			(*z)[zb0001] = nil
		} else {
			if (*z)[zb0001] == nil {
				(*z)[zb0001] = new(ListItem)
			}
			bts, err = (*z)[zb0001].UnmarshalMsg(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ListItems) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize
	for zb0003 := range z {
		if z[zb0003] == nil {
			s += msgp.NilSize
		} else {
			s += z[zb0003].Msgsize()
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *PlayerItemInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "Info"
	// map header, size 2
	// string "ID"
	o = append(o, 0x81, 0xa4, 0x49, 0x6e, 0x66, 0x6f, 0x82, 0xa2, 0x49, 0x44)
	o = msgp.AppendInt(o, z.Info.ID)
	// string "Type"
	o = append(o, 0xa4, 0x54, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Info.Type)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PlayerItemInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			return
		}
		switch msgp.UnsafeString(field) {
		case "Info":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					return
				}
				switch msgp.UnsafeString(field) {
				case "ID":
					z.Info.ID, bts, err = msgp.ReadIntBytes(bts)
					if err != nil {
						return
					}
				case "Type":
					z.Info.Type, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PlayerItemInfo) Msgsize() (s int) {
	s = 1 + 5 + 1 + 3 + msgp.IntSize + 5 + msgp.StringPrefixSize + len(z.Info.Type)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Resume) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "Position"
	o = append(o, 0x82, 0xa8, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendFloat64(o, z.Position)
	// string "Total"
	o = append(o, 0xa5, 0x54, 0x6f, 0x74, 0x61, 0x6c)
	o = msgp.AppendFloat64(o, z.Total)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Resume) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			return
		}
		switch msgp.UnsafeString(field) {
		case "Position":
			z.Position, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				return
			}
		case "Total":
			z.Total, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Resume) Msgsize() (s int) {
	s = 1 + 9 + msgp.Float64Size + 6 + msgp.Float64Size
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *StreamInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "Video"
	o = append(o, 0x83, 0xa5, 0x56, 0x69, 0x64, 0x65, 0x6f)
	if z.Video == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Video.MarshalMsg(o)
		if err != nil {
			return
		}
	}
	// string "Audio"
	o = append(o, 0xa5, 0x41, 0x75, 0x64, 0x69, 0x6f)
	if z.Audio == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Audio.MarshalMsg(o)
		if err != nil {
			return
		}
	}
	// string "Subtitle"
	o = append(o, 0xa8, 0x53, 0x75, 0x62, 0x74, 0x69, 0x74, 0x6c, 0x65)
	if z.Subtitle == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Subtitle.MarshalMsg(o)
		if err != nil {
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *StreamInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			return
		}
		switch msgp.UnsafeString(field) {
		case "Video":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Video = nil
			} else {
				if z.Video == nil {
					z.Video = new(StreamInfoEntry)
				}
				bts, err = z.Video.UnmarshalMsg(bts)
				if err != nil {
					return
				}
			}
		case "Audio":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Audio = nil
			} else {
				if z.Audio == nil {
					z.Audio = new(StreamInfoEntry)
				}
				bts, err = z.Audio.UnmarshalMsg(bts)
				if err != nil {
					return
				}
			}
		case "Subtitle":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Subtitle = nil
			} else {
				if z.Subtitle == nil {
					z.Subtitle = new(StreamInfoEntry)
				}
				bts, err = z.Subtitle.UnmarshalMsg(bts)
				if err != nil {
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *StreamInfo) Msgsize() (s int) {
	s = 1 + 6
	if z.Video == nil {
		s += msgp.NilSize
	} else {
		s += z.Video.Msgsize()
	}
	s += 6
	if z.Audio == nil {
		s += msgp.NilSize
	} else {
		s += z.Audio.Msgsize()
	}
	s += 9
	if z.Subtitle == nil {
		s += msgp.NilSize
	} else {
		s += z.Subtitle.Msgsize()
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *StreamInfoEntry) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 7
	// string "Codec"
	o = append(o, 0x87, 0xa5, 0x43, 0x6f, 0x64, 0x65, 0x63)
	o = msgp.AppendString(o, z.Codec)
	// string "Aspect"
	o = append(o, 0xa6, 0x41, 0x73, 0x70, 0x65, 0x63, 0x74)
	o = msgp.AppendFloat32(o, z.Aspect)
	// string "Width"
	o = append(o, 0xa5, 0x57, 0x69, 0x64, 0x74, 0x68)
	o = msgp.AppendInt(o, z.Width)
	// string "Height"
	o = append(o, 0xa6, 0x48, 0x65, 0x69, 0x67, 0x68, 0x74)
	o = msgp.AppendInt(o, z.Height)
	// string "Duration"
	o = append(o, 0xa8, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendInt(o, z.Duration)
	// string "Language"
	o = append(o, 0xa8, 0x4c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65)
	o = msgp.AppendString(o, z.Language)
	// string "Channels"
	o = append(o, 0xa8, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73)
	o = msgp.AppendInt(o, z.Channels)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *StreamInfoEntry) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			return
		}
		switch msgp.UnsafeString(field) {
		case "Codec":
			z.Codec, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Aspect":
			z.Aspect, bts, err = msgp.ReadFloat32Bytes(bts)
			if err != nil {
				return
			}
		case "Width":
			z.Width, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "Height":
			z.Height, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "Duration":
			z.Duration, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "Language":
			z.Language, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Channels":
			z.Channels, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *StreamInfoEntry) Msgsize() (s int) {
	s = 1 + 6 + msgp.StringPrefixSize + len(z.Codec) + 7 + msgp.Float32Size + 6 + msgp.IntSize + 7 + msgp.IntSize + 9 + msgp.IntSize + 9 + msgp.StringPrefixSize + len(z.Language) + 9 + msgp.IntSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *UniqueIDs) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 8
	// string "Unknown"
	o = append(o, 0x88, 0xa7, 0x55, 0x6e, 0x6b, 0x6e, 0x6f, 0x77, 0x6e)
	o = msgp.AppendString(o, z.Unknown)
	// string "TMDB"
	o = append(o, 0xa4, 0x54, 0x4d, 0x44, 0x42)
	o = msgp.AppendString(o, z.TMDB)
	// string "TVDB"
	o = append(o, 0xa4, 0x54, 0x56, 0x44, 0x42)
	o = msgp.AppendString(o, z.TVDB)
	// string "IMDB"
	o = append(o, 0xa4, 0x49, 0x4d, 0x44, 0x42)
	o = msgp.AppendString(o, z.IMDB)
	// string "TheMovieDB"
	o = append(o, 0xaa, 0x54, 0x68, 0x65, 0x4d, 0x6f, 0x76, 0x69, 0x65, 0x44, 0x42)
	o = msgp.AppendString(o, z.TheMovieDB)
	// string "Trakt"
	o = append(o, 0xa5, 0x54, 0x72, 0x61, 0x6b, 0x74)
	o = msgp.AppendString(o, z.Trakt)
	// string "Elementum"
	o = append(o, 0xa9, 0x45, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x75, 0x6d)
	o = msgp.AppendString(o, z.Elementum)
	// string "Kodi"
	o = append(o, 0xa4, 0x4b, 0x6f, 0x64, 0x69)
	o = msgp.AppendInt(o, z.Kodi)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *UniqueIDs) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			return
		}
		switch msgp.UnsafeString(field) {
		case "Unknown":
			z.Unknown, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "TMDB":
			z.TMDB, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "TVDB":
			z.TVDB, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "IMDB":
			z.IMDB, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "TheMovieDB":
			z.TheMovieDB, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Trakt":
			z.Trakt, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Elementum":
			z.Elementum, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Kodi":
			z.Kodi, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *UniqueIDs) Msgsize() (s int) {
	s = 1 + 8 + msgp.StringPrefixSize + len(z.Unknown) + 5 + msgp.StringPrefixSize + len(z.TMDB) + 5 + msgp.StringPrefixSize + len(z.TVDB) + 5 + msgp.StringPrefixSize + len(z.IMDB) + 11 + msgp.StringPrefixSize + len(z.TheMovieDB) + 6 + msgp.StringPrefixSize + len(z.Trakt) + 10 + msgp.StringPrefixSize + len(z.Elementum) + 5 + msgp.IntSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *VideoLibraryEpisode) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "Episode"
	o = append(o, 0x81, 0xa7, 0x45, 0x70, 0x69, 0x73, 0x6f, 0x64, 0x65)
	if z.Episode == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Episode.MarshalMsg(o)
		if err != nil {
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VideoLibraryEpisode) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			return
		}
		switch msgp.UnsafeString(field) {
		case "Episode":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Episode = nil
			} else {
				if z.Episode == nil {
					z.Episode = new(VideoLibraryEpisodeItem)
				}
				bts, err = z.Episode.UnmarshalMsg(bts)
				if err != nil {
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VideoLibraryEpisode) Msgsize() (s int) {
	s = 1 + 8
	if z.Episode == nil {
		s += msgp.NilSize
	} else {
		s += z.Episode.Msgsize()
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *VideoLibraryEpisodeItem) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 9
	// string "ID"
	o = append(o, 0x89, 0xa2, 0x49, 0x44)
	o = msgp.AppendInt(o, z.ID)
	// string "Title"
	o = append(o, 0xa5, 0x54, 0x69, 0x74, 0x6c, 0x65)
	o = msgp.AppendString(o, z.Title)
	// string "Season"
	o = append(o, 0xa6, 0x53, 0x65, 0x61, 0x73, 0x6f, 0x6e)
	o = msgp.AppendInt(o, z.Season)
	// string "Episode"
	o = append(o, 0xa7, 0x45, 0x70, 0x69, 0x73, 0x6f, 0x64, 0x65)
	o = msgp.AppendInt(o, z.Episode)
	// string "TVShowID"
	o = append(o, 0xa8, 0x54, 0x56, 0x53, 0x68, 0x6f, 0x77, 0x49, 0x44)
	o = msgp.AppendInt(o, z.TVShowID)
	// string "PlayCount"
	o = append(o, 0xa9, 0x50, 0x6c, 0x61, 0x79, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendInt(o, z.PlayCount)
	// string "File"
	o = append(o, 0xa4, 0x46, 0x69, 0x6c, 0x65)
	o = msgp.AppendString(o, z.File)
	// string "UniqueIDs"
	o = append(o, 0xa9, 0x55, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49, 0x44, 0x73)
	o, err = z.UniqueIDs.MarshalMsg(o)
	if err != nil {
		return
	}
	// string "Resume"
	o = append(o, 0xa6, 0x52, 0x65, 0x73, 0x75, 0x6d, 0x65)
	if z.Resume == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "Position"
		o = append(o, 0x82, 0xa8, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e)
		o = msgp.AppendFloat64(o, z.Resume.Position)
		// string "Total"
		o = append(o, 0xa5, 0x54, 0x6f, 0x74, 0x61, 0x6c)
		o = msgp.AppendFloat64(o, z.Resume.Total)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VideoLibraryEpisodeItem) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			return
		}
		switch msgp.UnsafeString(field) {
		case "ID":
			z.ID, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "Title":
			z.Title, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Season":
			z.Season, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "Episode":
			z.Episode, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "TVShowID":
			z.TVShowID, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "PlayCount":
			z.PlayCount, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "File":
			z.File, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "UniqueIDs":
			bts, err = z.UniqueIDs.UnmarshalMsg(bts)
			if err != nil {
				return
			}
		case "Resume":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Resume = nil
			} else {
				if z.Resume == nil {
					z.Resume = new(Resume)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						return
					}
					switch msgp.UnsafeString(field) {
					case "Position":
						z.Resume.Position, bts, err = msgp.ReadFloat64Bytes(bts)
						if err != nil {
							return
						}
					case "Total":
						z.Resume.Total, bts, err = msgp.ReadFloat64Bytes(bts)
						if err != nil {
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							return
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VideoLibraryEpisodeItem) Msgsize() (s int) {
	s = 1 + 3 + msgp.IntSize + 6 + msgp.StringPrefixSize + len(z.Title) + 7 + msgp.IntSize + 8 + msgp.IntSize + 9 + msgp.IntSize + 10 + msgp.IntSize + 5 + msgp.StringPrefixSize + len(z.File) + 10 + z.UniqueIDs.Msgsize() + 7
	if z.Resume == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 9 + msgp.Float64Size + 6 + msgp.Float64Size
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *VideoLibraryEpisodes) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "Episodes"
	o = append(o, 0x81, 0xa8, 0x45, 0x70, 0x69, 0x73, 0x6f, 0x64, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Episodes)))
	for za0001 := range z.Episodes {
		if z.Episodes[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Episodes[za0001].MarshalMsg(o)
			if err != nil {
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VideoLibraryEpisodes) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			return
		}
		switch msgp.UnsafeString(field) {
		case "Episodes":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				return
			}
			if cap(z.Episodes) >= int(zb0002) {
				z.Episodes = (z.Episodes)[:zb0002]
			} else {
				z.Episodes = make([]*VideoLibraryEpisodeItem, zb0002)
			}
			for za0001 := range z.Episodes {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Episodes[za0001] = nil
				} else {
					if z.Episodes[za0001] == nil {
						z.Episodes[za0001] = new(VideoLibraryEpisodeItem)
					}
					bts, err = z.Episodes[za0001].UnmarshalMsg(bts)
					if err != nil {
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VideoLibraryEpisodes) Msgsize() (s int) {
	s = 1 + 9 + msgp.ArrayHeaderSize
	for za0001 := range z.Episodes {
		if z.Episodes[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Episodes[za0001].Msgsize()
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z VideoLibraryLimits) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "End"
	o = append(o, 0x83, 0xa3, 0x45, 0x6e, 0x64)
	o = msgp.AppendInt(o, z.End)
	// string "Start"
	o = append(o, 0xa5, 0x53, 0x74, 0x61, 0x72, 0x74)
	o = msgp.AppendInt(o, z.Start)
	// string "Total"
	o = append(o, 0xa5, 0x54, 0x6f, 0x74, 0x61, 0x6c)
	o = msgp.AppendInt(o, z.Total)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VideoLibraryLimits) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			return
		}
		switch msgp.UnsafeString(field) {
		case "End":
			z.End, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "Start":
			z.Start, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "Total":
			z.Total, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z VideoLibraryLimits) Msgsize() (s int) {
	s = 1 + 4 + msgp.IntSize + 6 + msgp.IntSize + 6 + msgp.IntSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *VideoLibraryMovieItem) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 8
	// string "ID"
	o = append(o, 0x88, 0xa2, 0x49, 0x44)
	o = msgp.AppendInt(o, z.ID)
	// string "Title"
	o = append(o, 0xa5, 0x54, 0x69, 0x74, 0x6c, 0x65)
	o = msgp.AppendString(o, z.Title)
	// string "IMDBNumber"
	o = append(o, 0xaa, 0x49, 0x4d, 0x44, 0x42, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72)
	o = msgp.AppendString(o, z.IMDBNumber)
	// string "PlayCount"
	o = append(o, 0xa9, 0x50, 0x6c, 0x61, 0x79, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendInt(o, z.PlayCount)
	// string "File"
	o = append(o, 0xa4, 0x46, 0x69, 0x6c, 0x65)
	o = msgp.AppendString(o, z.File)
	// string "Year"
	o = append(o, 0xa4, 0x59, 0x65, 0x61, 0x72)
	o = msgp.AppendInt(o, z.Year)
	// string "UniqueIDs"
	o = append(o, 0xa9, 0x55, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49, 0x44, 0x73)
	o, err = z.UniqueIDs.MarshalMsg(o)
	if err != nil {
		return
	}
	// string "Resume"
	o = append(o, 0xa6, 0x52, 0x65, 0x73, 0x75, 0x6d, 0x65)
	if z.Resume == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "Position"
		o = append(o, 0x82, 0xa8, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e)
		o = msgp.AppendFloat64(o, z.Resume.Position)
		// string "Total"
		o = append(o, 0xa5, 0x54, 0x6f, 0x74, 0x61, 0x6c)
		o = msgp.AppendFloat64(o, z.Resume.Total)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VideoLibraryMovieItem) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			return
		}
		switch msgp.UnsafeString(field) {
		case "ID":
			z.ID, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "Title":
			z.Title, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "IMDBNumber":
			z.IMDBNumber, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "PlayCount":
			z.PlayCount, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "File":
			z.File, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Year":
			z.Year, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "UniqueIDs":
			bts, err = z.UniqueIDs.UnmarshalMsg(bts)
			if err != nil {
				return
			}
		case "Resume":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Resume = nil
			} else {
				if z.Resume == nil {
					z.Resume = new(Resume)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						return
					}
					switch msgp.UnsafeString(field) {
					case "Position":
						z.Resume.Position, bts, err = msgp.ReadFloat64Bytes(bts)
						if err != nil {
							return
						}
					case "Total":
						z.Resume.Total, bts, err = msgp.ReadFloat64Bytes(bts)
						if err != nil {
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							return
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VideoLibraryMovieItem) Msgsize() (s int) {
	s = 1 + 3 + msgp.IntSize + 6 + msgp.StringPrefixSize + len(z.Title) + 11 + msgp.StringPrefixSize + len(z.IMDBNumber) + 10 + msgp.IntSize + 5 + msgp.StringPrefixSize + len(z.File) + 5 + msgp.IntSize + 10 + z.UniqueIDs.Msgsize() + 7
	if z.Resume == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 9 + msgp.Float64Size + 6 + msgp.Float64Size
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *VideoLibraryMovies) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "Limits"
	o = append(o, 0x82, 0xa6, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x73)
	if z.Limits == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 3
		// string "End"
		o = append(o, 0x83, 0xa3, 0x45, 0x6e, 0x64)
		o = msgp.AppendInt(o, z.Limits.End)
		// string "Start"
		o = append(o, 0xa5, 0x53, 0x74, 0x61, 0x72, 0x74)
		o = msgp.AppendInt(o, z.Limits.Start)
		// string "Total"
		o = append(o, 0xa5, 0x54, 0x6f, 0x74, 0x61, 0x6c)
		o = msgp.AppendInt(o, z.Limits.Total)
	}
	// string "Movies"
	o = append(o, 0xa6, 0x4d, 0x6f, 0x76, 0x69, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Movies)))
	for za0001 := range z.Movies {
		if z.Movies[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Movies[za0001].MarshalMsg(o)
			if err != nil {
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VideoLibraryMovies) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			return
		}
		switch msgp.UnsafeString(field) {
		case "Limits":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Limits = nil
			} else {
				if z.Limits == nil {
					z.Limits = new(VideoLibraryLimits)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						return
					}
					switch msgp.UnsafeString(field) {
					case "End":
						z.Limits.End, bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							return
						}
					case "Start":
						z.Limits.Start, bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							return
						}
					case "Total":
						z.Limits.Total, bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							return
						}
					}
				}
			}
		case "Movies":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				return
			}
			if cap(z.Movies) >= int(zb0003) {
				z.Movies = (z.Movies)[:zb0003]
			} else {
				z.Movies = make([]*VideoLibraryMovieItem, zb0003)
			}
			for za0001 := range z.Movies {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Movies[za0001] = nil
				} else {
					if z.Movies[za0001] == nil {
						z.Movies[za0001] = new(VideoLibraryMovieItem)
					}
					bts, err = z.Movies[za0001].UnmarshalMsg(bts)
					if err != nil {
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VideoLibraryMovies) Msgsize() (s int) {
	s = 1 + 7
	if z.Limits == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 4 + msgp.IntSize + 6 + msgp.IntSize + 6 + msgp.IntSize
	}
	s += 7 + msgp.ArrayHeaderSize
	for za0001 := range z.Movies {
		if z.Movies[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Movies[za0001].Msgsize()
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *VideoLibrarySeason) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "Episode"
	o = append(o, 0x81, 0xa7, 0x45, 0x70, 0x69, 0x73, 0x6f, 0x64, 0x65)
	if z.Episode == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Episode.MarshalMsg(o)
		if err != nil {
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VideoLibrarySeason) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			return
		}
		switch msgp.UnsafeString(field) {
		case "Episode":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Episode = nil
			} else {
				if z.Episode == nil {
					z.Episode = new(VideoLibrarySeasonItem)
				}
				bts, err = z.Episode.UnmarshalMsg(bts)
				if err != nil {
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VideoLibrarySeason) Msgsize() (s int) {
	s = 1 + 8
	if z.Episode == nil {
		s += msgp.NilSize
	} else {
		s += z.Episode.Msgsize()
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *VideoLibrarySeasonItem) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 7
	// string "ID"
	o = append(o, 0x87, 0xa2, 0x49, 0x44)
	o = msgp.AppendInt(o, z.ID)
	// string "Title"
	o = append(o, 0xa5, 0x54, 0x69, 0x74, 0x6c, 0x65)
	o = msgp.AppendString(o, z.Title)
	// string "Season"
	o = append(o, 0xa6, 0x53, 0x65, 0x61, 0x73, 0x6f, 0x6e)
	o = msgp.AppendInt(o, z.Season)
	// string "Episodes"
	o = append(o, 0xa8, 0x45, 0x70, 0x69, 0x73, 0x6f, 0x64, 0x65, 0x73)
	o = msgp.AppendInt(o, z.Episodes)
	// string "TVShowID"
	o = append(o, 0xa8, 0x54, 0x56, 0x53, 0x68, 0x6f, 0x77, 0x49, 0x44)
	o = msgp.AppendInt(o, z.TVShowID)
	// string "PlayCount"
	o = append(o, 0xa9, 0x50, 0x6c, 0x61, 0x79, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendInt(o, z.PlayCount)
	// string "UniqueIDs"
	o = append(o, 0xa9, 0x55, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49, 0x44, 0x73)
	o, err = z.UniqueIDs.MarshalMsg(o)
	if err != nil {
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VideoLibrarySeasonItem) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			return
		}
		switch msgp.UnsafeString(field) {
		case "ID":
			z.ID, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "Title":
			z.Title, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Season":
			z.Season, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "Episodes":
			z.Episodes, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "TVShowID":
			z.TVShowID, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "PlayCount":
			z.PlayCount, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "UniqueIDs":
			bts, err = z.UniqueIDs.UnmarshalMsg(bts)
			if err != nil {
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VideoLibrarySeasonItem) Msgsize() (s int) {
	s = 1 + 3 + msgp.IntSize + 6 + msgp.StringPrefixSize + len(z.Title) + 7 + msgp.IntSize + 9 + msgp.IntSize + 9 + msgp.IntSize + 10 + msgp.IntSize + 10 + z.UniqueIDs.Msgsize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *VideoLibrarySeasons) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "Seasons"
	o = append(o, 0x81, 0xa7, 0x53, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Seasons)))
	for za0001 := range z.Seasons {
		if z.Seasons[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Seasons[za0001].MarshalMsg(o)
			if err != nil {
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VideoLibrarySeasons) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			return
		}
		switch msgp.UnsafeString(field) {
		case "Seasons":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				return
			}
			if cap(z.Seasons) >= int(zb0002) {
				z.Seasons = (z.Seasons)[:zb0002]
			} else {
				z.Seasons = make([]*VideoLibrarySeasonItem, zb0002)
			}
			for za0001 := range z.Seasons {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Seasons[za0001] = nil
				} else {
					if z.Seasons[za0001] == nil {
						z.Seasons[za0001] = new(VideoLibrarySeasonItem)
					}
					bts, err = z.Seasons[za0001].UnmarshalMsg(bts)
					if err != nil {
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VideoLibrarySeasons) Msgsize() (s int) {
	s = 1 + 8 + msgp.ArrayHeaderSize
	for za0001 := range z.Seasons {
		if z.Seasons[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Seasons[za0001].Msgsize()
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *VideoLibraryShowItem) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 7
	// string "ID"
	o = append(o, 0x87, 0xa2, 0x49, 0x44)
	o = msgp.AppendInt(o, z.ID)
	// string "Title"
	o = append(o, 0xa5, 0x54, 0x69, 0x74, 0x6c, 0x65)
	o = msgp.AppendString(o, z.Title)
	// string "IMDBNumber"
	o = append(o, 0xaa, 0x49, 0x4d, 0x44, 0x42, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72)
	o = msgp.AppendString(o, z.IMDBNumber)
	// string "PlayCount"
	o = append(o, 0xa9, 0x50, 0x6c, 0x61, 0x79, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendInt(o, z.PlayCount)
	// string "Year"
	o = append(o, 0xa4, 0x59, 0x65, 0x61, 0x72)
	o = msgp.AppendInt(o, z.Year)
	// string "Episodes"
	o = append(o, 0xa8, 0x45, 0x70, 0x69, 0x73, 0x6f, 0x64, 0x65, 0x73)
	o = msgp.AppendInt(o, z.Episodes)
	// string "UniqueIDs"
	o = append(o, 0xa9, 0x55, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49, 0x44, 0x73)
	o, err = z.UniqueIDs.MarshalMsg(o)
	if err != nil {
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VideoLibraryShowItem) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			return
		}
		switch msgp.UnsafeString(field) {
		case "ID":
			z.ID, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "Title":
			z.Title, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "IMDBNumber":
			z.IMDBNumber, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "PlayCount":
			z.PlayCount, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "Year":
			z.Year, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "Episodes":
			z.Episodes, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				return
			}
		case "UniqueIDs":
			bts, err = z.UniqueIDs.UnmarshalMsg(bts)
			if err != nil {
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VideoLibraryShowItem) Msgsize() (s int) {
	s = 1 + 3 + msgp.IntSize + 6 + msgp.StringPrefixSize + len(z.Title) + 11 + msgp.StringPrefixSize + len(z.IMDBNumber) + 10 + msgp.IntSize + 5 + msgp.IntSize + 9 + msgp.IntSize + 10 + z.UniqueIDs.Msgsize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *VideoLibraryShows) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "Limits"
	o = append(o, 0x82, 0xa6, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x73)
	if z.Limits == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 3
		// string "End"
		o = append(o, 0x83, 0xa3, 0x45, 0x6e, 0x64)
		o = msgp.AppendInt(o, z.Limits.End)
		// string "Start"
		o = append(o, 0xa5, 0x53, 0x74, 0x61, 0x72, 0x74)
		o = msgp.AppendInt(o, z.Limits.Start)
		// string "Total"
		o = append(o, 0xa5, 0x54, 0x6f, 0x74, 0x61, 0x6c)
		o = msgp.AppendInt(o, z.Limits.Total)
	}
	// string "Shows"
	o = append(o, 0xa5, 0x53, 0x68, 0x6f, 0x77, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Shows)))
	for za0001 := range z.Shows {
		if z.Shows[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Shows[za0001].MarshalMsg(o)
			if err != nil {
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VideoLibraryShows) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			return
		}
		switch msgp.UnsafeString(field) {
		case "Limits":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Limits = nil
			} else {
				if z.Limits == nil {
					z.Limits = new(VideoLibraryLimits)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						return
					}
					switch msgp.UnsafeString(field) {
					case "End":
						z.Limits.End, bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							return
						}
					case "Start":
						z.Limits.Start, bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							return
						}
					case "Total":
						z.Limits.Total, bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							return
						}
					}
				}
			}
		case "Shows":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				return
			}
			if cap(z.Shows) >= int(zb0003) {
				z.Shows = (z.Shows)[:zb0003]
			} else {
				z.Shows = make([]*VideoLibraryShowItem, zb0003)
			}
			for za0001 := range z.Shows {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Shows[za0001] = nil
				} else {
					if z.Shows[za0001] == nil {
						z.Shows[za0001] = new(VideoLibraryShowItem)
					}
					bts, err = z.Shows[za0001].UnmarshalMsg(bts)
					if err != nil {
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VideoLibraryShows) Msgsize() (s int) {
	s = 1 + 7
	if z.Limits == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 4 + msgp.IntSize + 6 + msgp.IntSize + 6 + msgp.IntSize
	}
	s += 6 + msgp.ArrayHeaderSize
	for za0001 := range z.Shows {
		if z.Shows[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Shows[za0001].Msgsize()
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *View) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "ContentType"
	o = append(o, 0x82, 0xab, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x54, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.ContentType)
	// string "Items"
	o = append(o, 0xa5, 0x49, 0x74, 0x65, 0x6d, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Items)))
	for za0001 := range z.Items {
		if z.Items[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Items[za0001].MarshalMsg(o)
			if err != nil {
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *View) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			return
		}
		switch msgp.UnsafeString(field) {
		case "ContentType":
			z.ContentType, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				return
			}
		case "Items":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				return
			}
			if cap(z.Items) >= int(zb0002) {
				z.Items = (z.Items)[:zb0002]
			} else {
				z.Items = make(ListItems, zb0002)
			}
			for za0001 := range z.Items {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Items[za0001] = nil
				} else {
					if z.Items[za0001] == nil {
						z.Items[za0001] = new(ListItem)
					}
					bts, err = z.Items[za0001].UnmarshalMsg(bts)
					if err != nil {
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *View) Msgsize() (s int) {
	s = 1 + 12 + msgp.StringPrefixSize + len(z.ContentType) + 6 + msgp.ArrayHeaderSize
	for za0001 := range z.Items {
		if z.Items[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Items[za0001].Msgsize()
		}
	}
	return
}
